Ответы на вопросы для самоконтроля
1. В чем разница между event.preventDefault() и event.stopPropagation()? В каких ситуациях используется каждый метод?**  
**event.preventDefault()** - предотвращает стандартное поведение браузера (например, отправку формы, переход по ссылке)  
**event.stopPropagation()** - останавливает всплытие события по DOM-дереву  
**Использование:**  
- `preventDefault()` - когда нужно обработать действие самостоятельно (кастомная валидация формы, модальные окна вместо переходов)  
- `stopPropagation()` - когда нужно изолировать событие от родительских элементов (вложенные кликабельные элементы)  
2. Как работает делегирование событий и какие преимущества оно дает по сравнению с назначением обработчиков на отдельные элементы?**  
**Делегирование событий** - назначение одного обработчика на родительский элемент для обработки событий дочерних элементов через всплытие  
**Преимущества:**  
- Экономия памяти (один обработчик вместо многих)  
- Работа с динамически добавляемыми элементами без перепривязки  
- Упрощение кода и уменьшение количества слушателей  
3. Какие фазы жизненного цикла события существуют в JavaScript (capturing, target, bubbling) и как они влияют на порядок выполнения обработчиков?**  
**Фазы:**  
1. **Capturing (перехват)** - событие идет сверху вниз от window к целевому элементу  
2. **Target (цель)** - событие достигло целевого элемента  
3. **Bubbling (всплытие)** - событие поднимается снизу вверх от целевого элемента к window  
**Влияние:** Обработчики выполняются в порядке фаз, если не используется `stopPropagation()`  
**4. В чем разница между event.target и event.currentTarget? Когда следует использовать каждый из них?**  
**event.target** - элемент, который инициировал событие (исходный целевой элемент)  
**event.currentTarget** - элемент, на котором в данный момент выполняется обработчик  
**Использование:**  
- `event.target` - когда нужно знать, на каком именно элементе произошло событие  
- `event.currentTarget` - когда нужен элемент с привязанным обработчиком (особенно при делегировании)  
**5. Как создать и запустить кастомное событие? Какие параметры можно передать в конструктор CustomEvent?**  
**Создание:**  
```javascript  
const event = new CustomEvent('myEvent', {  
    detail: { message: 'Данные события' },  
    bubbles: true,  
    cancelable: true  
});  
Запуск: element.dispatchEvent(event);
Параметры: detail (данные), bubbles (всплытие), cancelable (отменяемость)
6. Что такое debounce и throttle? В каких практических ситуациях их применение наиболее эффективно?
Debounce - откладывает выполнение функции до окончания серии быстрых вызовов
Throttle - ограничивает частоту выполнения функции (не чаще чем раз в X мс)
Применение:
Debounce: поиск по вводу, валидация форм, изменение размера окна
Throttle: скроллинг, перемещение мыши, игровые контролы
7. Какие методы существуют для удаления обработчиков событий и почему важно удалять ненужные обработчики?
Методы:
removeEventListener('click', handler)
element.onclick = null
Важность удаления:
Предотвращение утечек памяти
Избежание дублирования обработчиков
Повышение производительности
8. Как обрабатывать ошибки загрузки ресурсов (изображений, скриптов) и какие события для этого используются?
Обработка ошибок:
javascript
img.addEventListener('error', function() {  
    // Действия при ошибке загрузки  
});  
События: load (успешная загрузка), error (ошибка), loadstart (начало загрузки), loadend (окончание загрузки)
9. В чем разница между addEventListener и прямым назначением обработчиков через onclick, onkeydown и т.д.?
addEventListener:
Позволяет добавлять несколько обработчиков на одно событие
Имеет больше опций (capture, once, passive)
Более гибкое управление
Прямое назначение:
Только один обработчик на событие
Проще синтаксис для базовых случаев
10. Как оптимизировать производительность при работе с большим количеством событий? Какие лучшие практики существуют?
Лучшие практики:
Использовать делегирование событий
Применять debounce/throttle для частых событий
Удалять ненужные обработчики
Использовать пассивные обработчики для scroll/touch событий
Избегать частых операций с DOM в обработчиках
Использовать requestAnimationFrame для анимаций