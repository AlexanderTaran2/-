1.useState подходит для простых состояний (примитивы, простые объекты), возвращает значение и сеттер. useReducer лучше для сложных состояний, когда следующее состояние зависит от предыдущего или есть сложная бизнес-логика. Используйте useState для независимых состояний, useReducer - когда состояния связаны или логика обновления сложная.
2.Массив зависимостей в useEffect определяет, при изменении каких переменых перезапускается эффект. Пустой массив [] - эффект запускается только при монтировании. Если массив не указан - эффект выполняется после каждого рендера. Если указаны зависимости [a, b] - эффект запускается при изменении a или b.
3."Stale closure" возникает когда функция внутри хука использует устаревшее значение из замыкания. Для избежания используйте функциональные обновления в useState: setCount(prev => prev + 1) вместо setCount(count + 1), и для useReducer передавайте функцию в dispatch.
4.useCallback и useMemo нужны когда: передаете функции/объекты в дочерние компоненты (memo), используете в зависимостях эффектов, дорогие вычисления. Это не преждевременная оптимизация если есть измеримые проблемы производительности.
5.useRef хранит мутируемое значение, которое не вызывает ререндер при изменении. useState вызывает ререндер. useRef незаменим для: доступа к DOM-элементам, хранения таймеров, интервалов, любых мутируемых значений которые не должны触发ть ререндер.
6.Правила хуков: вызывать только на верхнем уровне (не в циклах, условиях, вложенных функциях) и только из React-компонентов или кастомных хуков. Нарушение ломает порядок вызова хуков, что ведет к багам.
7.Кастомный хук создается как функция с именем на use*, которая может использовать другие хуки. Лучшие практики: четкое назначение, следование правилам хуков, возврат понятного API.
8.useContext преимущества: избавление от "prop drilling", централизация состояния, более чистая кодовая база. Недостатки: ненужные ререндеры если не оптимизировать, усложнение логики при переиспользовании компонентов.
9.Асинхронные операции в кастомных хуках обрабатываются через useState для состояния загрузки/ошибок/данных, useEffect для запуска, useCallback для мемоизации функций. Обязательно обрабатывать размонтирование.
10.Способы отладки хуков: React DevTools, console.log в эффектах, использование useDebugValue в кастомных хуках, проверка массивов зависимостей, анализ ререндеров с React.memo и useMemo.